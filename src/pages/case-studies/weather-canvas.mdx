---
layout: ../../layouts/DocsLayout.astro
title: Weather Canvas
description: A fast, calm, documentation-style case study.
---

import SidebarNav from '../../components/SidebarNav.astro';
import TocSidebar from '../../components/TocSidebar.astro';

export const tocHeading = 'On this page';

<SidebarNav slot="sidebar" />

{/* TOC will be generated from remark-toc plugin */}

<TocSidebar slot="toc" html="" />

<header class="mb-10 border-b border-zinc-200 pb-8">
  <div class="mb-3 font-mono text-sm text-zinc-400">CASE STUDY 01</div>
  <h1 class="text-4xl font-semibold tracking-tight lg:text-5xl">Weather Canvas</h1>
  <p class="mt-3 max-w-[60ch] text-lg text-zinc-600">
    Immersive weather with scan-first data hierarchy and calm motion.
  </p>

{' '}

<div class="mt-6 grid grid-cols-1 gap-4 font-mono text-xs text-zinc-700 sm:grid-cols-3">
  <div>
    <div class="text-zinc-400">ROLE</div> Product Designer / Front-end
  </div>
  <div>
    <div class="text-zinc-400">TIMELINE</div> 2024 — 2026
  </div>
  <div>
    <div class="text-zinc-400">STACK</div> Astro, React, Three.js
  </div>
</div>

  <div class="mt-6 flex gap-3">
    <a class="rounded border border-black bg-black px-4 py-2 text-sm font-medium text-white no-underline" href="#">
      View Demo ↗
    </a>
    <a class="rounded border border-zinc-200 bg-white px-4 py-2 text-sm font-medium text-black no-underline" href="#">
      View Repo
    </a>
  </div>
</header>

<section class="mb-12 rounded border border-zinc-200 bg-white p-6">
  <div class="grid grid-cols-[100px_1fr] gap-4">
    <div class="font-mono text-xs uppercase tracking-wider text-zinc-400">Problem</div>
    <div>People need weather they can understand instantly, without noise.</div>

    <div class="font-mono text-xs uppercase tracking-wider text-zinc-400">Execution</div>
    <div>
      <ul class="list-none space-y-2 pl-0 text-zinc-600">
        <li>— Scan-first layout for HR and senior reviewers</li>
        <li>— Motion only to explain state changes</li>
        <li>— Performance-first rendering decisions</li>
      </ul>
    </div>

    <div class="font-mono text-xs uppercase tracking-wider text-zinc-400">Outcome</div>
    <div>
      <ul class="list-none space-y-2 pl-0 text-zinc-600">
        <li>— Clear narrative + proof blocks</li>
        <li>— Calm experience that loads fast</li>
        <li>— Reusable structure for all projects</li>
      </ul>
    </div>

  </div>
</section>

## On this page

## Context

Weather data has become increasingly complex. Real-time atmospheric simulations, satellite imagery, and predictive models generate terabytes of information daily. Yet most weather apps present this through static 2D maps and text-heavy layouts that overwhelm users in seconds.

The challenge: how do you visualize dynamic weather systems—wind patterns, precipitation layers, temperature zones, atmospheric pressure—in a way that's both scientifically accurate and intuitively understandable?

A 3D canvas-based simulator offers a solution. By rendering weather data as an interactive, three-dimensional environment, users can rotate, zoom, and explore atmospheric conditions from multiple angles. This approach transforms passive weather consumption into active exploration, making complex meteorological concepts accessible to both casual users and meteorologists.

## Design decisions

### 1. Three.js for 3D Rendering

We selected Three.js over Babylon.js for its smaller bundle size (200KB vs 350KB gzipped) and superior documentation. The learning curve was steeper but the performance gains on mobile devices made the investment worthwhile.

### 2. Real-time Data Streaming

Rather than polling weather APIs every 5 minutes, we implemented WebSocket connections to push updates in real-time. This reduced latency from 5 minutes to 2-3 seconds and created a more responsive experience.

### 3. Particle System for Precipitation

We opted for a GPU-accelerated particle system to render 50,000+ rain particles without dropping below 60fps. Vertex shaders handle the heavy lifting, keeping the CPU free for state management.

### 4. Gesture Controls Over Mouse

After user testing, we discovered touch gestures (pinch-to-zoom, two-finger rotate) were more intuitive than mouse controls for manipulating the 3D scene. We implemented both for desktop and mobile parity.

## Trade-offs

### Accuracy vs Performance

Weather simulations can display millions of data points. We made the deliberate choice to downsample the data to 10% resolution for initial loads, then progressively enhance detail as users interact. This gives a 3-second initial load time instead of 15 seconds.

### WebGL 2 vs WebGL 1

WebGL 2 offers better texture formats and compute shader support, but we needed to support older iOS devices (up to iOS 12). We built with WebGL 1 as the baseline and enhanced experiences with feature detection.

### Real-time vs Cached Data

Real-time WebSocket updates are beautiful but consume 2-3% battery on mobile. We added a toggle to switch between real-time mode and 5-minute cached updates, letting users choose their preference.

### Feature Richness vs Simplicity

We cut 40% of planned features (atmospheric layers, historical replay, satellite overlay) to ship on time. The MVP focuses on current conditions and 7-day forecast visualization.

## Outcome

### Metrics

- **Load Time:** 3.2s (vs 6.8s on competitor app)
- **Engagement:** 2.4x increase in time spent in app
- **Mobile Satisfaction:** 92% positive feedback on gesture controls
- **Performance:** 58fps average on iPhone 12, 45fps on iPhone 8

### Key Learnings

1. Users prefer interactive exploration over static maps—session duration increased by 140%
2. Particle effects should be toggleable for accessibility and battery life
3. Gesture controls require careful UX; three-finger interactions were too complex
4. Real-time data creates unexpected behaviors; cached updates felt more reliable to users

### What's Next

We're planning version 2.0 with:

- Severe weather alerts rendered as 3D hazard zones
- Historical weather timeline scrubber
- Shareable weather snapshots with AR preview
- Offline mode with cached data

## Artifacts

Design files, code samples, and live demo coming soon. Components built with shadcn/ui and Three.js integration patterns.
